![GitHub commit activity](https://img.shields.io/github/commit-activity/t/TolikRogov/Language)
![GitHub repo size](https://img.shields.io/github/repo-size/TolikRogov/Language)
![GitHub Repo stars](https://img.shields.io/github/stars/TolikRogov/Language)
![GitHub top language](https://img.shields.io/github/languages/top/TolikRogov/Language)

# Language

---

## Оглавление

- [Введение](#введение)
- [Цель и задачи](#цель-и-задачи)
- [Установка и запуск](#установка-и-запуск)
- [Ключевые слова](#ключевые-слова)
- [Лексический анализ](#лексический-анализ)
- [Frontend](#frontend)
- [Стандарт дерева](#стандарт-дерева)
- [Middleware](#middleware)
- [Backend](#backend)
- [Обратный Frontend](#обратный-frontend)
- [Backend on Nasm](#backend-on-nasm)
- [Благодарности](#благодарности)

---

## Введение

**_Компилятор_** — программа, преобразующая исходный код, написанный на языке программирования, в язык машинных команд, которые понятны процессору.

Для анализа исходного кода программы используется такие инструменты как:

- Лексический анализ — разбивает код на условные единицы - **_токены_** (ключевые слова - **_key words_**, переменные - **_identifiers_**, непосредственные значения - **_immediate operands_**).

- Синтаксический анализ — проверяет код на соответствие установленным правилам грамматики.

> [!NOTE]
> Для более удобного описания этих правил обычно используется расширенная форма Бэкус-Наура (Extended Backus-Naur Form) - `формальная система определения синтаксиса, в которой одни синтаксические категории последовательно определяются через другие` - источник [Wikipedia/Extended-Backus-Naur-form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form).

- Семантический анализ — проверяет типы данных и области видимости переменных.

Немаловажной составляющей инструментария компилятора является **_Промежуточное представление_** (intermediate representation - IR) - позволяет в удобной для каждого их этапов компилятора форме отражать полную информацию об исходном коде программы. Зачастую, промежуточное представление является **_Абстрактным синтаксическим деревом_** (AST), которое в дальнейшем используется для оптимизаций программы и генерации машинных команд в исполняемый файл.

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Цель и задачи

**_Цель_** - реализовать основные стадии компиляции программы на собственном языке программирования в язык машинных команд своего процессора/инструкции Netwide Assembler x86-64.

**_Задачи_**:

1. Составить грамматику языка
2. Реализовать лексический анализ исходного файла программы
3. Реализовать синтаксический анализ подготовленного кода
4. Выбрать промежуточное представление языка
5. Провести простейшие оптимизации промежуточного представления
6. Реализовать трансляцию AST в машинные инструкции собственного процессора/инструкции NASM x86-64.

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Установка и запуск

Чтобы воспользоваться возможностями данного проекта, необходимо скопировать репозиторий, прописав следующую строку в терминале:

```
git clone https://github.com/TolikRogov/Language
```

В файле [`main.txt`](data/main.txt) записывается основной текст программы. Допустимый синтаксис языка будет описан далее. Для работы программы необходимо запустить _файл-старта_, находясь в корневом каталоге проекта:

```
./run
```

> [!NOTE]
> Программа последовательно запустит основные этапы проекта, после чего будет предложено выбрать файл, который нужно будет исполнить [процессору](https://github.com/TolikRogov/Processor).

Для запуска отдельных частей необходимо перейти в один из следующих каталогов: [`Frontend`](Frontend), [`Middleware`](Middleware), [`Backend`](Backend), [`ReverseFrontend`](ReverseFrontend) - прописав аналогичную команду.

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Ключевые слова

Ключевые слова представляют собой набор из определенного количества зарезервированных слов, каждое из которых обладает уникальным номером (как и всё ключевое слово целиком), а также имеет последовательность строковых символов (в моём случае, символов кириллицы), непосредственно составляющих данное ключевое слово.

В таблице перечислены все ключевые слова, использующиеся в моём языке, с их значениями на языке C:

| Номер |        Ключевое слово        | Значение |
| :---: | :--------------------------: | :------: |
|   1   |         всё позабыл          |    )     |
|   2   |       прыгнул со скалы       |    {     |
|   3   |       дикий крик издав       |    }     |
|   5   |     но вышло всё не так      |   else   |
|   6   |      на ужин пригласил       |   pow    |
|   9   |        зашёл в тупик         |    (     |
|  11   |    один лишь только путь     |    if    |
|  12   |          шёл домой           |  while   |
|  13   |          прокричал           |    =     |
|  21   |        грохочет гром         |   sin    |
|  22   |       сверкает молния        |   cos    |
|  23   |           на краю            |  floor   |
|  24   |           попросил           |    +     |
|  25   |           отказал            |    -     |
|  26   |            принёс            |    \*    |
|  27   |             унёс             |    /     |
|  28   |           на холме           |   diff   |
|  29   |        наступала ночь        |   sqrt   |
|  31   |        счастье обрёл         |    ==    |
|  32   | времени всё меньше посвящает |    <     |
|  33   |    интерес большой нашёл     |    >     |
|  34   |       не хватило силы        |    <=    |
|  35   |         весьма упрям         |    >=    |
|  36   |        отличие нашёл         |    !=    |
|  37   |           собрание           |    &&    |
|  38   |        смешной совет         |   \|\|   |
|  39   |         он не знает          |    !     |
|  41   |             хей              |    ;     |
|  42   |        во мраке ночи         |    ,     |
|  51   |        по лесу бродил        |  double  |
|  61   |             хой              |  input   |
|  62   |    коль желаешь расскажу     |  printf  |
|  71   |  ничего в жизни не вернуть   |  return  |
|  72   |   разбойники вышли толпой    |  break   |
|  73   |          смыкаю очи          | continue |
|  74   |       рухнул замертво        |  abort   |

> [!IMPORTANT]
> Номера ключевых слов выбраны с учётом соответствия [стандарту дерева](https://github.com/Iprime111/LanguageStandart).

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Лексический анализ

Считав текст программы из файла [`main.txt`](data/main.txt) в буфер строковых символов, вступает в действие лексический анализ. Идя по строке происходит поиск слов, составляющих ключевые слова, чисел типа double, остальные же строковые последовательности будут учтены как идентификаторы, которые будут занесены в таблицу имён:

<div align="center">
<figure style="text-align: center;">
    <img src='img/IdNameTable.png' alt="Таблица имён после лексического анализа" width="1000">
    <p>Рис. 1 - Таблица имён после лексического анализа</p>
</figure>
</div>

Последующие проходы по массиву токенов, сформированных лексическим анализом, позволяют учесть унарные минусы перед числами, а также определенные последовательности токенов объединяются в ключевое слово (набор заменяется одним токеном), если найдется соответствие в таблице замен, описанной в файле [`ReplaceTable.hpp`](KeyWords/ReplaceTable.hpp).

<div align="center">
<figure style="text-align: center;">
    <img src='img/Lexer.png' alt="Результаты проходов лексического анализа" width="1000">
    <p>Рис. 2 - Результаты проходов лексического анализа</p>
</figure>
</div>

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Frontend

Основная функция frontend части - синтаксический анализ результатов, полученных на этапе лексического анализа. Анализ синтаксиса реализован с помощью рекурсивного спуска по массиву токенов.

> [!IMPORTANT]
> С точки зрения синтаксиса программа в языке представляет собой последовательность функций, первая из которых всегда будет интерпретироваться как главная.

> [!NOTE]
> До определения функций имеется возможность объявить глобальные переменные так, что их имена больше нельзя будет использовать в качестве имён новых переменных.

Также добавлен вывод некоторых ошибок, обнаруженных на этапе синтаксического анализа. Например, ошибка использования необъявленной переменной:

<div align="center">
<figure style="text-align: center;">
   <img src='img/Error.png' alt="Ошибка необъявленной переменной" width="1000">
    <p>Рис. 3 - Ошибка необъявленной переменной</p>
</figure>
</div>

Результатом работы frontend-a являются два файла: [`tree_standard.txt`](data/tree_standard.txt) и [`name_table_standard.txt`](data/name_table_standard.txt), содержимое которых можно будет узнать из [стандарта дерева](#стандрат-дерева); а также дерево программы:

<div align="center">
<figure style="text-align: center;">
   <img src='img/Frontend_tree.png' alt="Дерево программы" width="1000">
    <p>Рис. 4 - Дерево программы</p>
</figure>
</div>

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Стандарт дерева

Для осуществления возможности обратной совместимости программ на разных языках программирования от разных разработчиков используется стандартная запись дерева программы в файл (в случае использованного стандарта - в два файла, содержащие само дерево и таблицу переменных, использующуюся непосредственно в программе).

> [!TIP]
> Всю подробную информацию о том в каком виде и по каким правилам записывается таблица переменных и дерево, можно узнать из репозитория стандарта, который используется в данном проекте: [https://github.com/Iprime111/LanguageStandart](https://github.com/Iprime111/LanguageStandart).

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Middleware

Для того, чтобы на этапе трансляции программы на язык ассемблера получившийся код не был слишком нагружен математическими выражениями, используется промежуточное программное обеспечение. В моём случае оно позволяет производить:

- свёртку констант - вычисление математических конструкций с числами
- операции с нейтральными элементами - умножение на 0 или на 1 и другие.
- дифференцирование математического выражения, если встречается ключевое слово diff.

Результатом работы является изменение содержимого файла [`tree_standard.txt`](data/tree_standard.txt).

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Backend

Данный этап позволяет произвести трансляцию дерева программы из файла [`tree_standard.txt`](data/tree_standard.txt) на язык ассемблера для его дальнейшего исполнения процессором.

> [!IMPORTANT]
> В данном проекте используется собственная реализация процессора, про который можно узнать из репозитория: [Processor](https://github.com/TolikRogov/Processor).

Результатом работы является файл [`main.asm`](Processor/data/main.asm):

<div align="center">
<figure style="text-align: center;">
  	<img src='img/asm.png' alt="Результаты Backend-а" width="1000">
    <p>Рис. 5 - Результаты Backend-а</p>
</figure>
</div>

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Обратный Frontend

Данный модуль позволяет получить из файлов, получившихся на этапе frontend-а у разработчика, который поддерживает такой же стандарт дерева, код программы на языке из данного проекта с использованием переменных из файловой таблицы имён.

Результатом работы является файл [`reverse_main.txt`](data/reverse_main.txt), пример:

<div align="center">
<figure style="text-align: center;">
  	<img src='img/reverse_front.png' alt="Результаты обратного Frontened-а" width="1000">
    <p>Рис. 5 - Результаты Backend-а</p>
</figure>
</div>

> [!WARNING]
> Получившаяся программа сохраняет отступы областей видимости переменных, но не сохраняет отступы между строками смысловых частей программы.

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Backend on Nasm

В качестве основы для нового backend-а был взят backend на собственный ассемблер, но были заменены совокупности инструкций при непосредственной трансляции. Однако, для полной реализации программы подобно предыдущему случаю необходимо поддерживать возможность ввода/вывода информации. Для этого были взяты написанные на языке ассемблера подобия функций [printf/scnaf](https://github.com/TolikRogov/Printf). Printf поддерживает часто используемые спецификаторы, а scanf только спецификатор для целочисленных значений.

<p align="right"><a href=#оглавление>(к оглавлению)</a></p>

---

## Благодарности

Отдельную благодарность хочется выразить моим наставникам:

- [ded32](https://github.com/ded32)
- [Amlola](https://github.com/Amlola)

А также составителям стандарта)
